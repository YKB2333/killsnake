#一、名词概念解释
####1、  DTO（Data Trans Object数据传输对象）用于定义web层接收参数，所有用于系统间交互的对象都可以统称为DTO
####2、  STO（Save Trans Object保存数据传输对象）DTO的细化延伸，用于定义进行新增操作接口的接收参数
####3、  MTO（Modify Trans Object 修改数据传输对象）DTO的细化延伸，用于定义进行修改操作接口的接收参数
####4、  QO（Query Object 查询条件对象）用于定义web层的查询接口的条件封装
####5、  VO（View Object 视图对象）聚合的展示对象，通常用于与前端进行数据交互
####6、  Model（数据模型）一个纯净的、只保存数据映射关系的模型
####7、  Entity（实体）指真实存在的个体对象，在代码中的实现为Model。 例如：ID为1的订单为一个实体，ID为2的订单为另一个实体
####8、  Aggreagate（聚合）指领域对象，由一个或多个类组成的为完成单一、完整功能的领域，在代码中以Biz层作为聚合的实现。 例如：订单、订单明细两者为订单领域
####9、  ValueObject（值对象）多个相关属性组合成为的一个概念整体，本质上是一个属性集合。用来保证属性归类的清晰和概念的完整性,避免属性零碎。例如：订单的收货地址有国家、省份、城市...，收货地址的值对象在订单中展现形式为 order:{id:1,address:{country:'中国',province:'湖南'..}}
####10、 模型关系：组合对象关系 特点为（组合内的对象）离开（组合体）就成为一个无完整意义的对象 例如：订单明细离开订单对象就变得毫无意义，只有在订单对象中才拥有意义。
####11、 模型关系：关联对象关系 特点为两者相互关联却又都拥有单独的、完整的意义和行为 例如：订单和物流，两者相互关联，却又有相对独立、完整的意义和行为。

#二、分层职责
##Web  接口层
###1、完成对DTO的静态规则校验。#静态校验指不需要与数据库做交互的校验，例如：非空判断、范围区间校验
###2、一个接口可以对多个Biz进行调用。
###3、接收Biz层返回的Model数据并组装好VO响应请求。
###4、实际上Web可以看作为Biz的防腐层，防止一些非法数据可能导致的程序异常，控制用户层只能看到属于自己的数据。
##Biz     业务调配层
###1、对操作的业务返回结果进行校验。#例如：根据条件获取的订单数据是否为Null、订单信息修改返回结果是否正常。
###2、不允许与其他Biz层进行互调
###3、对需要多个Service共同完成的业务进行Service的编排、调用。这里的Service调用不限模块。例如：下单、支付、物流属于三个不同的模块功能，在Biz完成这三个模块的调配
###4、在这一层可以看出一个业务完整的流程，并且只关注业务流程。
##Service     业务逻辑层
###1、对操作进行业务规则的校验。#例如：修改的订单是否为当前登录用户所拥有的订单、订单发货前校验是否已支付
###2、具体业务的逻辑处理，这一层应当做好封装。例如：对外提供的save()入口，在save()中做好新增或修改的操作，不要让外部去判断是新增还是修改。
###3、一个Service原则上只能对应一个Repository,必须保持Service与Repository的垂直。（组合对象关系除外，组合对象关系请看概念解释）。
###4、组合体对象的Service拥有组合内对象的Repository入口，组合内对象不对外提供Service。
###5、调用Repository层进行数据交互
##Repository  仓储层
###1、这是比较轻量级的一层，只负责与数据库的交互。
###2、复杂SQL查询、报表统计使用XML的方式实现。

#三、代码规范
###1、目录结构 通常完整的目录格式为：组织类型.组织名称.系统名称.模块名称.聚合领域
####|lol.redScarf
####|——yjdf
####|—— ——web
####|—— —— ——facade //面对者，以面向的使用端进行命名 #例如：admin(管理后台)，client(客户端)
####|—— —— —— ——aggregate //以聚合的名称进行命名

####|—— ——biz
####|—— —— ——aggregate //以聚合的名称进行命名，存放聚合内的Biz

####|—— ——service
####|—— —— ——aggregate //以聚合的名称进行命名，存放聚合内的Service

####|—— ——domain
####|—— —— ——aggregate
####|—— —— —— ——repository //mapper接口和xml都放在该目录下
####|—— —— —— ——model //enum、value object和model一起放在该目录下

####|—— ——event
####|—— —— ——aggregate //以聚合的名称进行命名，存放聚合内的事件实体，存放聚合内的事件监听者，一个事件实体对应一个监听者

####|—— ——dto
####|—— —— ——facade //面对者，以面向的使用端进行命名 #例如：admin(管理后台)，client(客户端)
####|—— —— —— ——aggregate //对外进行的交互的DTO、STO、MTO、QO、VO放在对应的聚合下

####|—— ——infrastructure //模块内的基础设施(通用的配置、工具等)
####|—— —— ——utils
####|—— —— ——config

###2、数据模型
####2.1类型以业务意义来命名并且遵循驼峰规范，命名应当完整、客观、清晰无歧义、能清晰表达业务意义。
####2.2在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度
####2.3对象关联关系和组合关系在Model中通过mybatis plus的@TableField(exist = false)注解声明关系
####2.4类名、属性命名不超过20长度的禁止缩写，缩写需要定义缩写意义和维护缩写文档
####2.5具体实现请看查询示例中的Model

###3、restful接口
####3.1URL命名格式通常为：面向端/模块名称/聚合根名称/子聚合名称/功能 #例如：admin/goods/spu/sku/enable
####3.2URL命名禁止缩写

###4、函数规范
####4.1函数命名以在当下完成的功能命名并且遵循驼峰规范，命名应当完整、客观、清晰无歧义、能清晰表达完成功能。
####4.2单个方法的总行数不超过 80 行。
####4.3代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。
####4.4不对外开放的方法要私有化。
####4.5函数命名不超过20长度的禁止缩写，缩写需要定义缩写意义和维护缩写文档禁止缩写

###5、状态规约
####5.1枚举的使用场景：变量值仅在一个固定范围内变化用 Enum 类型来定义。
####5.2使用枚举规约状态值的好处：统一管理、易维护、不存在意外值。
####5.3枚举在仓储层中的持久化实现：实现com.baomidou.mybatisplus.core.enums.IEnum<T> 接口并重写getValue()方法
####5.4枚举的序列化：在VO中手动添加枚举的状态的说明值
####5.5枚举的反序列化：在spring web中默认使用的jackson框架中通过枚举名称或索引进行反序列化
####5.6具体实现请看枚举示例

###6、查询
####6.1原则上列表查询不允许关联查询，当接受到这样的需求时可以和需求发起人沟通具体实现或通过冗余等其他手段实现。
####6.2单条明细查询时应当带出对象的关联关系、组合关系（关联对象关系、组合对象关系请查看名词概念解释）。例如：订单明细查询时应当带出订单明细、物流信息
####6.4组合关系对象在组合体的Service中组装至Model中
####6.5关联关系对象在Biz中通过各自的Service组装至Model中
####6.6在Web中将Model转换为VO对象并响应给前端用户
####6.7分页对象统一使用PageResponse.java
####6.8具体实现请看查询示例

###7、事件
####7.1当发生某种操作后会对一个或多个其他模块会产生间接影响、间接调用，这种操作造成的影响可以定义为事件。例如：用户注册后初始化钱包信息、注册日志、登录日志..
####7.2使用事件时要结合实际场景思考事件是否要求强一致性，对于要求强一致性的事件应当考虑是否有必要定义为一个事件，如有必要请做好强一致性处理。
####7.3事件命名以发生的操作命名。例如：用户注册后事件名：UserRegisteredEvent/UserRegisterAfterEvent/UserRegisterSuccessEvent
####7.4单个模块事件在Service层抛出，多个模块共同产生的事件在Biz层抛出。
####7.5具体实现请看事件示例

###8、异常使用与处理
####8.1静态参数校验不通过使用自定义异常：ParamentException.class
####8.2业务校验异常使用自定义异常：ValidationException.class/BusinessException.java
####8.3异常不要用捕捉来做流程分支，条件分支。抛出异常是指业务出现某种原因导致业务无法进行下去
####8.4不要做无意义的捕获异常操作。不需要处理的异常逐层抛出，直到全局的异常捕获器处理为止。
####8.5自定义异常抛出时需要定义错误码和错误信息。
####8.6具体实现请看异常示例

###9、日志打印
####9.1使用lombok插件下的@Slf4j注解，生成日志门面入口类进行日志的打印。
####9.2在日志输出时，字符串变量之间的拼接使用占位符的方式。#例如log.debug("Processing trade with id: {} and symbol: {}", id, symbol);
####9.3避免重复，无意义的日志打印 

#四、日常使用工具与小技巧
###1、DTO静态校验
####1.1校验规则的定义：实现ValidatorDto.java接口并重写validate()的业务逻辑
####1.2校验规则的使用：基于@RequestMapping注解的切面会执行实现ValidatorDto的validate()，无需手动调用执行。
####1.3具体实现请看静态参数校验

###2、对象的转换与组装
####2.1简单的实体转换：使用静态工厂模式，完成实体与VO的转换。
####2.2复杂的实体组装：使用Builder建造模式逐步的组装、建造VO对象。
####2.3具体实现请看对象转换

###3、雪花ID自生成、操作时间自动填充。
####3.1将与业务逻辑无关且具有通用性的功能抽象化、自动化。让开发同学只需关注业务逻辑
####3.2具体实现请看示例

更多详情请参考阿里Java开发手册（泰山版）;